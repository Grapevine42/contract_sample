#!/usr/bin/env python
# -*- coding: utf-8 -*-
import json
from os.path import dirname

import logging

from loopchain.blockchain import ScoreBase
from loopchain.tools import ScoreDatabaseType, ScoreHelper

#
class UserScore(ScoreBase):
    CONTRACT_DB_ID = 'contract'
    USER_DB_ID = 'user'
    LOG_PREFIX = "[CONTRACT SAMPLE SCORE] "
    DB_ENCODING = "utf-8"
    # for find last index
    LAST_INDEX_KEY = 'last_index'

    # json keys
    KEY = "key"
    VALUE = "value"

    def __init__(self, info=None):
        """init score dir
        """
        super().__init__(info)
        if info is None:
            with open(dirname(__file__)+'/'+ScoreBase.PACKAGE_FILE, "r") as f:
                self.__score_info = json.loads(f.read())
                f.close()
        else:
            self.__score_info = info
        self.__contract_db = None


    def __init_db(self):
        helper = ScoreHelper()
        if self.__contract_db is None:
            logging.debug(self.LOG_PREFIX + "Init DB(%s)", self.CONTRACT_DB_ID)

            self.__contract_db = LocalDB(self.CONTRACT_DB_ID)
        if self.__user_db is None:
            logging.debug(self.LOG_PREFIX + "Init DB(%s)", self.USER_DB_ID)
            self.__user_db = LocalDB(self.USER_DB_ID)

    def invoke_foo1(self, log_func, id, params: dict, block=None):

        # Use id as key.
        key = params["key"]
        value = params["value"]

        try:
            # Store string as value. And key and value must be BYTE type, not only string or object.
            self.__db.put(key.encode(), value.encode())
        except TypeError:
            return SCOREResponse.exception("key or value is not byte-like data.")

        # Validate key and value.
        try:
            value_from_db = self.__db.get_in_invoke(key.encode())
            if value != value_from_db.decode():
                return SCOREResponse.exception("Internal DB error.")

        # Handle exceptions.
        except TypeError:
            return SCOREResponse.exception("Key or value is not byte-like data.")

        except KeyError:
            return SCOREResponse.exception("DB do not Have such a key.")

        # Succeed to operate. Return successful message.
        log_func("Succeed to execute invoke_foo1.")
        return SCOREResponse.succeed()

    def query_foo1(self, log_func, id, params):
        """Query example function. USE AS REFERENCE. KEEP THIS FUNCTION ARGUMENTS IN YOUR OWN FUNCTIONS.

        In this example, we'll look up value by key in params.

        :param log_func: log function. use like this: log_func("message").
        :type score_db: ScoreHelperDatabase
        :param score_db: SCORE DB utility module
        :param params: parameters from the Tx
        :param id: id of JSON RPC 2.0 request
        :return Dictionary generated by SCOREResponse class.
        """

        key = params["key"]
        log_func("Begin query_foo1.")

        try:
            data = self.__db.get_in_query(key.encode())

            result = {"data": data.decode("utf-8")}
            log_func(f'Queried data: {result}')
            return SCOREResponse.succeed("Succeed to query.", result)

        except TypeError:
            return SCOREResponse.exception("Key or value is not byte-like data.")

        except KeyError:
            return SCOREResponse.exception("DB do not Have such a key.")




class LocalDB:

    DB_ENCODING = "utf-8"

    def __init__(self, db_name):
        helper = ScoreHelper()
        self.db = helper.load_database(score_id=db_name, database_type=ScoreDatabaseType.leveldb)

    def get(self, key):
        """

        :param key: string key
        :return:
        """
        byte_key = bytes(str(key), self.DB_ENCODING)
        try:
            return self.db.get(byte_key)
        except Exception as e:
            return None

    def put(self, key, value):
        """

        :param key: string key
        :param value: string value
        :return:
        """
        byte_key = bytes(str(key), self.DB_ENCODING)
        byte_value = bytes(str(value), self.DB_ENCODING)
        self.db.put(byte_key, byte_value)
